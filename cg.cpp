/**************
 * 
 *  file cg.cpp
 *  Created on Wed Apr 12 2023 
 *  generated by chatgpt, 
 *  Xiaodong LIU (xiaodong.liu@cnrs.fr)
 * 
 * 
 * 
 *  Copyright (c) 2023 Xiaodong LIU GeM, CNRS UMR6183
 * 
 **************/


#include "cg.h"
#include <cmath>


double dotProduct(const vector<double>& a, const vector<double>& b) {
    double result = 0.0;
    for(int i = 0; i < a.size(); i++) {
        result += a[i] * b[i];
    }
    return result;
}

vector<double> conjugateGradient(const vector<vector<double>>& A, const vector<double>& b, vector<double>& x0, int maxIterations, double tolerance) {
    int n = A.size();
    vector<double> r(n), p(n), Ap(n);
    vector<double> x = x0;
    r = b;
    p = r;

    for(int k = 0; k < maxIterations; k++) {
        double alpha = dotProduct(r, r) / dotProduct(p, Ap);
        for(int i = 0; i < n; i++) {
            x[i] += alpha * p[i];
            r[i] -= alpha * Ap[i];
        }
        double beta = dotProduct(r, r) / dotProduct(p, Ap);
        for(int i = 0; i < n; i++) {
            p[i] = r[i] + beta * p[i];
        }
        // Compute Ap = A*p
        for(int i = 0; i < n; i++) {
            Ap[i] = 0.0;
            for(int j = 0; j < n; j++) {
                Ap[i] += A[i][j] * p[j];
            }
        }
        double residualError = sqrt(dotProduct(r, r));
        if(residualError < tolerance) {
            cout << "Conjugate Gradient converged in " << k+1 << " iterations." << endl;
            break;
        }
        if(k == maxIterations - 1) {
            cout << "Conjugate Gradient did not converge within " << maxIterations << " iterations." << endl;
        }
    }
    return x;
}